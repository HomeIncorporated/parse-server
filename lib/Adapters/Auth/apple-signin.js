"use strict";

const Parse = require('parse/node').Parse;

const httpsRequest = require('./httpsRequest');

const NodeRSA = require('node-rsa');

const jwt = require('jsonwebtoken');

const TOKEN_ISSUER = 'https://appleid.apple.com';

const getApplePublicKey = async () => {
  const data = await httpsRequest.get('https://appleid.apple.com/auth/keys');
  const key = data.keys[0];
  const pubKey = new NodeRSA();
  pubKey.importKey({
    n: Buffer.from(key.n, 'base64'),
    e: Buffer.from(key.e, 'base64')
  }, 'components-public');
  return pubKey.exportKey(['public']);
};

const verifyIdToken = async (token, clientID) => {
  if (!token) {
    throw new Parse.Error(Parse.Error.OBJECT_NOT_FOUND, 'id_token is invalid for this user.');
  }

  const applePublicKey = await getApplePublicKey();
  const jwtClaims = jwt.verify(token, applePublicKey, {
    algorithms: 'RS256'
  });

  if (jwtClaims.iss !== TOKEN_ISSUER) {
    throw new Parse.Error(Parse.Error.OBJECT_NOT_FOUND, `id_token not issued by correct OpenID provider - expected: ${TOKEN_ISSUER} | from: ${jwtClaims.iss}`);
  }

  if (clientID !== undefined && jwtClaims.aud !== clientID) {
    throw new Parse.Error(Parse.Error.OBJECT_NOT_FOUND, `jwt aud parameter does not include this client - is: ${jwtClaims.aud} | expected: ${clientID}`);
  }

  return jwtClaims;
}; // Returns a promise that fulfills if this id_token is valid


function validateAuthData(authData, options = {}) {
  return verifyIdToken(authData.id_token, options.client_id);
} // Returns a promise that fulfills if this app id is valid.


function validateAppId() {
  return Promise.resolve();
}

module.exports = {
  validateAppId: validateAppId,
  validateAuthData: validateAuthData
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9BZGFwdGVycy9BdXRoL2FwcGxlLXNpZ25pbi5qcyJdLCJuYW1lcyI6WyJQYXJzZSIsInJlcXVpcmUiLCJodHRwc1JlcXVlc3QiLCJOb2RlUlNBIiwiand0IiwiVE9LRU5fSVNTVUVSIiwiZ2V0QXBwbGVQdWJsaWNLZXkiLCJkYXRhIiwiZ2V0Iiwia2V5Iiwia2V5cyIsInB1YktleSIsImltcG9ydEtleSIsIm4iLCJCdWZmZXIiLCJmcm9tIiwiZSIsImV4cG9ydEtleSIsInZlcmlmeUlkVG9rZW4iLCJ0b2tlbiIsImNsaWVudElEIiwiRXJyb3IiLCJPQkpFQ1RfTk9UX0ZPVU5EIiwiYXBwbGVQdWJsaWNLZXkiLCJqd3RDbGFpbXMiLCJ2ZXJpZnkiLCJhbGdvcml0aG1zIiwiaXNzIiwidW5kZWZpbmVkIiwiYXVkIiwidmFsaWRhdGVBdXRoRGF0YSIsImF1dGhEYXRhIiwib3B0aW9ucyIsImlkX3Rva2VuIiwiY2xpZW50X2lkIiwidmFsaWRhdGVBcHBJZCIsIlByb21pc2UiLCJyZXNvbHZlIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJtYXBwaW5ncyI6Ijs7QUFBQSxNQUFNQSxLQUFLLEdBQUdDLE9BQU8sQ0FBQyxZQUFELENBQVAsQ0FBc0JELEtBQXBDOztBQUNBLE1BQU1FLFlBQVksR0FBR0QsT0FBTyxDQUFDLGdCQUFELENBQTVCOztBQUNBLE1BQU1FLE9BQU8sR0FBR0YsT0FBTyxDQUFDLFVBQUQsQ0FBdkI7O0FBQ0EsTUFBTUcsR0FBRyxHQUFHSCxPQUFPLENBQUMsY0FBRCxDQUFuQjs7QUFFQSxNQUFNSSxZQUFZLEdBQUcsMkJBQXJCOztBQUVBLE1BQU1DLGlCQUFpQixHQUFHLFlBQVk7QUFDcEMsUUFBTUMsSUFBSSxHQUFHLE1BQU1MLFlBQVksQ0FBQ00sR0FBYixDQUFpQixxQ0FBakIsQ0FBbkI7QUFDQSxRQUFNQyxHQUFHLEdBQUdGLElBQUksQ0FBQ0csSUFBTCxDQUFVLENBQVYsQ0FBWjtBQUVBLFFBQU1DLE1BQU0sR0FBRyxJQUFJUixPQUFKLEVBQWY7QUFDQVEsRUFBQUEsTUFBTSxDQUFDQyxTQUFQLENBQ0U7QUFBRUMsSUFBQUEsQ0FBQyxFQUFFQyxNQUFNLENBQUNDLElBQVAsQ0FBWU4sR0FBRyxDQUFDSSxDQUFoQixFQUFtQixRQUFuQixDQUFMO0FBQW1DRyxJQUFBQSxDQUFDLEVBQUVGLE1BQU0sQ0FBQ0MsSUFBUCxDQUFZTixHQUFHLENBQUNPLENBQWhCLEVBQW1CLFFBQW5CO0FBQXRDLEdBREYsRUFFRSxtQkFGRjtBQUlBLFNBQU9MLE1BQU0sQ0FBQ00sU0FBUCxDQUFpQixDQUFDLFFBQUQsQ0FBakIsQ0FBUDtBQUNELENBVkQ7O0FBWUEsTUFBTUMsYUFBYSxHQUFHLE9BQU9DLEtBQVAsRUFBY0MsUUFBZCxLQUEyQjtBQUMvQyxNQUFJLENBQUNELEtBQUwsRUFBWTtBQUNWLFVBQU0sSUFBSW5CLEtBQUssQ0FBQ3FCLEtBQVYsQ0FDSnJCLEtBQUssQ0FBQ3FCLEtBQU4sQ0FBWUMsZ0JBRFIsRUFFSixvQ0FGSSxDQUFOO0FBSUQ7O0FBQ0QsUUFBTUMsY0FBYyxHQUFHLE1BQU1qQixpQkFBaUIsRUFBOUM7QUFDQSxRQUFNa0IsU0FBUyxHQUFHcEIsR0FBRyxDQUFDcUIsTUFBSixDQUFXTixLQUFYLEVBQWtCSSxjQUFsQixFQUFrQztBQUFFRyxJQUFBQSxVQUFVLEVBQUU7QUFBZCxHQUFsQyxDQUFsQjs7QUFFQSxNQUFJRixTQUFTLENBQUNHLEdBQVYsS0FBa0J0QixZQUF0QixFQUFvQztBQUNsQyxVQUFNLElBQUlMLEtBQUssQ0FBQ3FCLEtBQVYsQ0FDSnJCLEtBQUssQ0FBQ3FCLEtBQU4sQ0FBWUMsZ0JBRFIsRUFFSCw4REFBNkRqQixZQUFhLFlBQVdtQixTQUFTLENBQUNHLEdBQUksRUFGaEcsQ0FBTjtBQUlEOztBQUNELE1BQUlQLFFBQVEsS0FBS1EsU0FBYixJQUEwQkosU0FBUyxDQUFDSyxHQUFWLEtBQWtCVCxRQUFoRCxFQUEwRDtBQUN4RCxVQUFNLElBQUlwQixLQUFLLENBQUNxQixLQUFWLENBQ0pyQixLQUFLLENBQUNxQixLQUFOLENBQVlDLGdCQURSLEVBRUgsd0RBQXVERSxTQUFTLENBQUNLLEdBQUksZ0JBQWVULFFBQVMsRUFGMUYsQ0FBTjtBQUlEOztBQUNELFNBQU9JLFNBQVA7QUFDRCxDQXZCRCxDLENBeUJBOzs7QUFDQSxTQUFTTSxnQkFBVCxDQUEwQkMsUUFBMUIsRUFBb0NDLE9BQU8sR0FBRyxFQUE5QyxFQUFrRDtBQUNoRCxTQUFPZCxhQUFhLENBQUNhLFFBQVEsQ0FBQ0UsUUFBVixFQUFvQkQsT0FBTyxDQUFDRSxTQUE1QixDQUFwQjtBQUNELEMsQ0FFRDs7O0FBQ0EsU0FBU0MsYUFBVCxHQUF5QjtBQUN2QixTQUFPQyxPQUFPLENBQUNDLE9BQVIsRUFBUDtBQUNEOztBQUVEQyxNQUFNLENBQUNDLE9BQVAsR0FBaUI7QUFDZkosRUFBQUEsYUFBYSxFQUFFQSxhQURBO0FBRWZMLEVBQUFBLGdCQUFnQixFQUFFQTtBQUZILENBQWpCIiwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgUGFyc2UgPSByZXF1aXJlKCdwYXJzZS9ub2RlJykuUGFyc2U7XG5jb25zdCBodHRwc1JlcXVlc3QgPSByZXF1aXJlKCcuL2h0dHBzUmVxdWVzdCcpO1xuY29uc3QgTm9kZVJTQSA9IHJlcXVpcmUoJ25vZGUtcnNhJyk7XG5jb25zdCBqd3QgPSByZXF1aXJlKCdqc29ud2VidG9rZW4nKTtcblxuY29uc3QgVE9LRU5fSVNTVUVSID0gJ2h0dHBzOi8vYXBwbGVpZC5hcHBsZS5jb20nO1xuXG5jb25zdCBnZXRBcHBsZVB1YmxpY0tleSA9IGFzeW5jICgpID0+IHtcbiAgY29uc3QgZGF0YSA9IGF3YWl0IGh0dHBzUmVxdWVzdC5nZXQoJ2h0dHBzOi8vYXBwbGVpZC5hcHBsZS5jb20vYXV0aC9rZXlzJyk7XG4gIGNvbnN0IGtleSA9IGRhdGEua2V5c1swXTtcblxuICBjb25zdCBwdWJLZXkgPSBuZXcgTm9kZVJTQSgpO1xuICBwdWJLZXkuaW1wb3J0S2V5KFxuICAgIHsgbjogQnVmZmVyLmZyb20oa2V5Lm4sICdiYXNlNjQnKSwgZTogQnVmZmVyLmZyb20oa2V5LmUsICdiYXNlNjQnKSB9LFxuICAgICdjb21wb25lbnRzLXB1YmxpYydcbiAgKTtcbiAgcmV0dXJuIHB1YktleS5leHBvcnRLZXkoWydwdWJsaWMnXSk7XG59O1xuXG5jb25zdCB2ZXJpZnlJZFRva2VuID0gYXN5bmMgKHRva2VuLCBjbGllbnRJRCkgPT4ge1xuICBpZiAoIXRva2VuKSB7XG4gICAgdGhyb3cgbmV3IFBhcnNlLkVycm9yKFxuICAgICAgUGFyc2UuRXJyb3IuT0JKRUNUX05PVF9GT1VORCxcbiAgICAgICdpZF90b2tlbiBpcyBpbnZhbGlkIGZvciB0aGlzIHVzZXIuJ1xuICAgICk7XG4gIH1cbiAgY29uc3QgYXBwbGVQdWJsaWNLZXkgPSBhd2FpdCBnZXRBcHBsZVB1YmxpY0tleSgpO1xuICBjb25zdCBqd3RDbGFpbXMgPSBqd3QudmVyaWZ5KHRva2VuLCBhcHBsZVB1YmxpY0tleSwgeyBhbGdvcml0aG1zOiAnUlMyNTYnIH0pO1xuXG4gIGlmIChqd3RDbGFpbXMuaXNzICE9PSBUT0tFTl9JU1NVRVIpIHtcbiAgICB0aHJvdyBuZXcgUGFyc2UuRXJyb3IoXG4gICAgICBQYXJzZS5FcnJvci5PQkpFQ1RfTk9UX0ZPVU5ELFxuICAgICAgYGlkX3Rva2VuIG5vdCBpc3N1ZWQgYnkgY29ycmVjdCBPcGVuSUQgcHJvdmlkZXIgLSBleHBlY3RlZDogJHtUT0tFTl9JU1NVRVJ9IHwgZnJvbTogJHtqd3RDbGFpbXMuaXNzfWBcbiAgICApO1xuICB9XG4gIGlmIChjbGllbnRJRCAhPT0gdW5kZWZpbmVkICYmIGp3dENsYWltcy5hdWQgIT09IGNsaWVudElEKSB7XG4gICAgdGhyb3cgbmV3IFBhcnNlLkVycm9yKFxuICAgICAgUGFyc2UuRXJyb3IuT0JKRUNUX05PVF9GT1VORCxcbiAgICAgIGBqd3QgYXVkIHBhcmFtZXRlciBkb2VzIG5vdCBpbmNsdWRlIHRoaXMgY2xpZW50IC0gaXM6ICR7and0Q2xhaW1zLmF1ZH0gfCBleHBlY3RlZDogJHtjbGllbnRJRH1gXG4gICAgKTtcbiAgfVxuICByZXR1cm4gand0Q2xhaW1zO1xufTtcblxuLy8gUmV0dXJucyBhIHByb21pc2UgdGhhdCBmdWxmaWxscyBpZiB0aGlzIGlkX3Rva2VuIGlzIHZhbGlkXG5mdW5jdGlvbiB2YWxpZGF0ZUF1dGhEYXRhKGF1dGhEYXRhLCBvcHRpb25zID0ge30pIHtcbiAgcmV0dXJuIHZlcmlmeUlkVG9rZW4oYXV0aERhdGEuaWRfdG9rZW4sIG9wdGlvbnMuY2xpZW50X2lkKTtcbn1cblxuLy8gUmV0dXJucyBhIHByb21pc2UgdGhhdCBmdWxmaWxscyBpZiB0aGlzIGFwcCBpZCBpcyB2YWxpZC5cbmZ1bmN0aW9uIHZhbGlkYXRlQXBwSWQoKSB7XG4gIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHZhbGlkYXRlQXBwSWQ6IHZhbGlkYXRlQXBwSWQsXG4gIHZhbGlkYXRlQXV0aERhdGE6IHZhbGlkYXRlQXV0aERhdGEsXG59O1xuIl19