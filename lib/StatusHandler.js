'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.flatten = flatten;
exports.jobStatusHandler = jobStatusHandler;
exports.pushStatusHandler = pushStatusHandler;

var _cryptoUtils = require('./cryptoUtils');

var _logger = require('./logger');

var _rest = require('./rest');

var _rest2 = _interopRequireDefault(_rest);

var _Auth = require('./Auth');

var _Auth2 = _interopRequireDefault(_Auth);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const PUSH_STATUS_COLLECTION = '_PushStatus';
const JOB_STATUS_COLLECTION = '_JobStatus';

const incrementOp = function (object = {}, key, amount = 1) {
  if (!object[key]) {
    object[key] = { __op: 'Increment', amount: amount };
  } else {
    object[key].amount += amount;
  }
  return object[key];
};

function flatten(array) {
  var flattened = [];
  for (var i = 0; i < array.length; i++) {
    if (Array.isArray(array[i])) {
      flattened = flattened.concat(flatten(array[i]));
    } else {
      flattened.push(array[i]);
    }
  }
  return flattened;
}

function statusHandler(className, database) {
  let lastPromise = Promise.resolve();

  function create(object) {
    lastPromise = lastPromise.then(() => {
      return database.create(className, object).then(() => {
        return Promise.resolve(object);
      });
    });
    return lastPromise;
  }

  function update(where, object) {
    lastPromise = lastPromise.then(() => {
      return database.update(className, where, object);
    });
    return lastPromise;
  }

  return Object.freeze({
    create,
    update
  });
}

function restStatusHandler(className, config) {
  let lastPromise = Promise.resolve();
  const auth = _Auth2.default.master(config);
  function create(object) {
    lastPromise = lastPromise.then(() => {
      return _rest2.default.create(config, auth, className, object).then(({ response }) => {
        // merge the objects
        return Promise.resolve(Object.assign({}, object, response));
      });
    });
    return lastPromise;
  }

  function update(where, object) {
    // TODO: when we have updateWhere, use that for proper interfacing
    lastPromise = lastPromise.then(() => {
      return _rest2.default.update(config, auth, className, { objectId: where.objectId }, object).then(({ response }) => {
        // merge the objects
        return Promise.resolve(Object.assign({}, object, response));
      });
    });
    return lastPromise;
  }

  return Object.freeze({
    create,
    update
  });
}

function jobStatusHandler(config) {
  let jobStatus;
  const objectId = (0, _cryptoUtils.newObjectId)(config.objectIdSize);
  const database = config.database;
  const handler = statusHandler(JOB_STATUS_COLLECTION, database);
  const setRunning = function (jobName, params) {
    const now = new Date();
    jobStatus = {
      objectId,
      jobName,
      params,
      status: 'running',
      source: 'api',
      createdAt: now,
      // lockdown!
      ACL: {}
    };

    return handler.create(jobStatus);
  };

  const setMessage = function (message) {
    if (!message || typeof message !== 'string') {
      return Promise.resolve();
    }
    return handler.update({ objectId }, { message });
  };

  const setSucceeded = function (message) {
    return setFinalStatus('succeeded', message);
  };

  const setFailed = function (message) {
    return setFinalStatus('failed', message);
  };

  const setFinalStatus = function (status, message = undefined) {
    const finishedAt = new Date();
    const update = { status, finishedAt };
    if (message && typeof message === 'string') {
      update.message = message;
    }
    return handler.update({ objectId }, update);
  };

  return Object.freeze({
    setRunning,
    setSucceeded,
    setMessage,
    setFailed
  });
}

function pushStatusHandler(config, existingObjectId) {

  let pushStatus;
  const database = config.database;
  const handler = restStatusHandler(PUSH_STATUS_COLLECTION, config);
  let objectId = existingObjectId;
  const setInitial = function (body = {}, where, options = { source: 'rest' }) {
    const now = new Date();
    let pushTime = now.toISOString();
    let status = 'pending';
    if (body.hasOwnProperty('push_time')) {
      if (config.hasPushScheduledSupport) {
        pushTime = body.push_time;
        status = 'scheduled';
      } else {
        _logger.logger.warn('Trying to schedule a push while server is not configured.');
        _logger.logger.warn('Push will be sent immediately');
      }
    }

    const data = body.data || {};
    const payloadString = JSON.stringify(data);
    let pushHash;
    if (typeof data.alert === 'string') {
      pushHash = (0, _cryptoUtils.md5Hash)(data.alert);
    } else if (typeof data.alert === 'object') {
      pushHash = (0, _cryptoUtils.md5Hash)(JSON.stringify(data.alert));
    } else {
      pushHash = 'd41d8cd98f00b204e9800998ecf8427e';
    }
    const object = {
      pushTime,
      query: JSON.stringify(where),
      payload: payloadString,
      source: options.source,
      title: options.title,
      expiry: body.expiration_time,
      expiration_interval: body.expiration_interval,
      status: status,
      numSent: 0,
      pushHash,
      // lockdown!
      ACL: {}
    };
    return handler.create(object).then(result => {
      objectId = result.objectId;
      pushStatus = {
        objectId
      };
      return Promise.resolve(pushStatus);
    });
  };

  const setRunning = function (batches) {
    _logger.logger.verbose(`_PushStatus ${objectId}: sending push to installations with %d batches`, batches);
    return handler.update({
      status: "pending",
      objectId: objectId
    }, {
      status: "running",
      count: batches
    });
  };

  const update = function (update) {
    _logger.logger.verbose(`_PushStatus ${objectId}: updating values %j`, update);
    return handler.update({ objectId }, update);
  };

  const trackSent = function (results, UTCOffset, cleanupInstallations = process.env.PARSE_SERVER_CLEANUP_INVALID_INSTALLATIONS) {
    const update = {
      numSent: 0,
      numFailed: 0
    };
    const devicesToRemove = [];
    if (Array.isArray(results)) {
      results = flatten(results);
      results.reduce((memo, result) => {
        // Cannot handle that
        if (!result || !result.device || !result.device.deviceType) {
          return memo;
        }
        const deviceType = result.device.deviceType;
        const key = result.transmitted ? `sentPerType.${deviceType}` : `failedPerType.${deviceType}`;
        memo[key] = incrementOp(memo, key);
        if (typeof UTCOffset !== 'undefined') {
          const offsetKey = result.transmitted ? `sentPerUTCOffset.${UTCOffset}` : `failedPerUTCOffset.${UTCOffset}`;
          memo[offsetKey] = incrementOp(memo, offsetKey);
        }
        if (result.transmitted) {
          memo.numSent++;
        } else {
          if (result && result.response && result.response.error && result.device && result.device.deviceToken) {
            const token = result.device.deviceToken;
            const error = result.response.error;
            // GCM errors
            if (error === 'NotRegistered' || error === 'InvalidRegistration') {
              devicesToRemove.push(token);
            }
            // APNS errors
            if (error === 'Unregistered' || error === 'BadDeviceToken') {
              devicesToRemove.push(token);
            }
          }
          memo.numFailed++;
        }
        return memo;
      }, update);
    }

    _logger.logger.verbose(`_PushStatus ${objectId}: sent push! %d success, %d failures`, update.numSent, update.numFailed);
    _logger.logger.verbose(`_PushStatus ${objectId}: needs cleanup`, { devicesToRemove });
    ['numSent', 'numFailed'].forEach(key => {
      if (update[key] > 0) {
        update[key] = {
          __op: 'Increment',
          amount: update[key]
        };
      } else {
        delete update[key];
      }
    });

    if (devicesToRemove.length > 0 && cleanupInstallations) {
      _logger.logger.info(`Removing device tokens on ${devicesToRemove.length} _Installations`);
      database.update('_Installation', { deviceToken: { '$in': devicesToRemove } }, { deviceToken: { "__op": "Delete" } }, {
        acl: undefined,
        many: true
      });
    }

    // indicate this batch is complete
    incrementOp(update, 'count', -1);

    return handler.update({ objectId }, update).then(res => {
      if (res && res.count === 0) {
        return this.complete();
      }
    });
  };

  const complete = function () {
    return handler.update({ objectId }, {
      status: 'succeeded',
      count: { __op: 'Delete' }
    });
  };

  const fail = function (err) {
    if (typeof err === 'string') {
      err = { message: err };
    }
    const update = {
      errorMessage: err,
      status: 'failed'
    };
    return handler.update({ objectId }, update);
  };

  const rval = {
    setInitial,
    setRunning,
    trackSent,
    complete,
    update,
    fail
  };

  // define objectId to be dynamic
  Object.defineProperty(rval, "objectId", {
    get: () => objectId
  });

  return Object.freeze(rval);
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9TdGF0dXNIYW5kbGVyLmpzIl0sIm5hbWVzIjpbImZsYXR0ZW4iLCJqb2JTdGF0dXNIYW5kbGVyIiwicHVzaFN0YXR1c0hhbmRsZXIiLCJQVVNIX1NUQVRVU19DT0xMRUNUSU9OIiwiSk9CX1NUQVRVU19DT0xMRUNUSU9OIiwiaW5jcmVtZW50T3AiLCJvYmplY3QiLCJrZXkiLCJhbW91bnQiLCJfX29wIiwiYXJyYXkiLCJmbGF0dGVuZWQiLCJpIiwibGVuZ3RoIiwiQXJyYXkiLCJpc0FycmF5IiwiY29uY2F0IiwicHVzaCIsInN0YXR1c0hhbmRsZXIiLCJjbGFzc05hbWUiLCJkYXRhYmFzZSIsImxhc3RQcm9taXNlIiwiUHJvbWlzZSIsInJlc29sdmUiLCJjcmVhdGUiLCJ0aGVuIiwidXBkYXRlIiwid2hlcmUiLCJPYmplY3QiLCJmcmVlemUiLCJyZXN0U3RhdHVzSGFuZGxlciIsImNvbmZpZyIsImF1dGgiLCJBdXRoIiwibWFzdGVyIiwicmVzdCIsInJlc3BvbnNlIiwiYXNzaWduIiwib2JqZWN0SWQiLCJqb2JTdGF0dXMiLCJvYmplY3RJZFNpemUiLCJoYW5kbGVyIiwic2V0UnVubmluZyIsImpvYk5hbWUiLCJwYXJhbXMiLCJub3ciLCJEYXRlIiwic3RhdHVzIiwic291cmNlIiwiY3JlYXRlZEF0IiwiQUNMIiwic2V0TWVzc2FnZSIsIm1lc3NhZ2UiLCJzZXRTdWNjZWVkZWQiLCJzZXRGaW5hbFN0YXR1cyIsInNldEZhaWxlZCIsInVuZGVmaW5lZCIsImZpbmlzaGVkQXQiLCJleGlzdGluZ09iamVjdElkIiwicHVzaFN0YXR1cyIsInNldEluaXRpYWwiLCJib2R5Iiwib3B0aW9ucyIsInB1c2hUaW1lIiwidG9JU09TdHJpbmciLCJoYXNPd25Qcm9wZXJ0eSIsImhhc1B1c2hTY2hlZHVsZWRTdXBwb3J0IiwicHVzaF90aW1lIiwibG9nZ2VyIiwid2FybiIsImRhdGEiLCJwYXlsb2FkU3RyaW5nIiwiSlNPTiIsInN0cmluZ2lmeSIsInB1c2hIYXNoIiwiYWxlcnQiLCJxdWVyeSIsInBheWxvYWQiLCJ0aXRsZSIsImV4cGlyeSIsImV4cGlyYXRpb25fdGltZSIsImV4cGlyYXRpb25faW50ZXJ2YWwiLCJudW1TZW50IiwicmVzdWx0IiwiYmF0Y2hlcyIsInZlcmJvc2UiLCJjb3VudCIsInRyYWNrU2VudCIsInJlc3VsdHMiLCJVVENPZmZzZXQiLCJjbGVhbnVwSW5zdGFsbGF0aW9ucyIsInByb2Nlc3MiLCJlbnYiLCJQQVJTRV9TRVJWRVJfQ0xFQU5VUF9JTlZBTElEX0lOU1RBTExBVElPTlMiLCJudW1GYWlsZWQiLCJkZXZpY2VzVG9SZW1vdmUiLCJyZWR1Y2UiLCJtZW1vIiwiZGV2aWNlIiwiZGV2aWNlVHlwZSIsInRyYW5zbWl0dGVkIiwib2Zmc2V0S2V5IiwiZXJyb3IiLCJkZXZpY2VUb2tlbiIsInRva2VuIiwiZm9yRWFjaCIsImluZm8iLCJhY2wiLCJtYW55IiwicmVzIiwiY29tcGxldGUiLCJmYWlsIiwiZXJyIiwiZXJyb3JNZXNzYWdlIiwicnZhbCIsImRlZmluZVByb3BlcnR5IiwiZ2V0Il0sIm1hcHBpbmdzIjoiOzs7OztRQWlCZ0JBLE8sR0FBQUEsTztRQXFFQUMsZ0IsR0FBQUEsZ0I7UUFxREFDLGlCLEdBQUFBLGlCOztBQTNJaEI7O0FBQ0E7O0FBQ0E7Ozs7QUFDQTs7Ozs7O0FBRUEsTUFBTUMseUJBQXlCLGFBQS9CO0FBQ0EsTUFBTUMsd0JBQXdCLFlBQTlCOztBQUVBLE1BQU1DLGNBQWMsVUFBU0MsU0FBUyxFQUFsQixFQUFzQkMsR0FBdEIsRUFBMkJDLFNBQVMsQ0FBcEMsRUFBdUM7QUFDekQsTUFBSSxDQUFDRixPQUFPQyxHQUFQLENBQUwsRUFBa0I7QUFDaEJELFdBQU9DLEdBQVAsSUFBYyxFQUFDRSxNQUFNLFdBQVAsRUFBb0JELFFBQVFBLE1BQTVCLEVBQWQ7QUFDRCxHQUZELE1BRU87QUFDTEYsV0FBT0MsR0FBUCxFQUFZQyxNQUFaLElBQXNCQSxNQUF0QjtBQUNEO0FBQ0QsU0FBT0YsT0FBT0MsR0FBUCxDQUFQO0FB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ekIsUUFBSSxPQUFPQSxHQUFQLEtBQWUsUUFBbkIsRUFBNkI7QUFDM0JBLFlBQU0sRUFBRTVELFNBQVM0RCxHQUFYLEVBQU47QUFDRDtBQUNELFVBQU10RixTQUFTO0FBQ2J1RixvQkFBY0QsR0FERDtBQUViakUsY0FBUTtBQUZLLEtBQWY7QUFJQSxXQUFPTixRQUFRZixNQUFSLENBQWUsRUFBRVksUUFBRixFQUFmLEVBQTZCWixNQUE3QixDQUFQO0FBQ0QsR0FURDs7QUFXQSxRQUFNd0YsT0FBTztBQUNYdEQsY0FEVztBQUVYbEIsY0FGVztBQUdYNkMsYUFIVztBQUlYdUIsWUFKVztBQUtYcEYsVUFMVztBQU1YcUY7QUFOVyxHQUFiOztBQVNBO0FBQ0FuRixTQUFPdUYsY0FBUCxDQUFzQkQsSUFBdEIsRUFBNEIsVUFBNUIsRUFBd0M7QUFDdENFLFNBQUssTUFBTTlFO0FBRDJCLEdBQXhDOztBQUlBLFNBQU9WLE9BQU9DLE1BQVAsQ0FBY3FGLElBQWQsQ0FBUDtBQUNEIiwiZmlsZSI6IlN0YXR1c0hhbmRsZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBtZDVIYXNoLCBuZXdPYmplY3RJZCB9IGZyb20gJy4vY3J5cHRvVXRpbHMnO1xuaW1wb3J0IHsgbG9nZ2VyIH0gICAgICAgICAgICAgICBmcm9tICcuL2xvZ2dlcic7XG5pbXBvcnQgcmVzdCAgICAgICAgICAgICAgICAgICAgIGZyb20gJy4vcmVzdCc7XG5pbXBvcnQgQXV0aCAgICAgICAgICAgICAgICAgICAgIGZyb20gJy4vQXV0aCc7XG5cbmNvbnN0IFBVU0hfU1RBVFVTX0NPTExFQ1RJT04gPSAnX1B1c2hTdGF0dXMnO1xuY29uc3QgSk9CX1NUQVRVU19DT0xMRUNUSU9OID0gJ19Kb2JTdGF0dXMnO1xuXG5jb25zdCBpbmNyZW1lbnRPcCA9IGZ1bmN0aW9uKG9iamVjdCA9IHt9LCBrZXksIGFtb3VudCA9IDEpIHtcbiAgaWYgKCFvYmplY3Rba2V5XSkge1xuICAgIG9iamVjdFtrZXldID0ge19fb3A6ICdJbmNyZW1lbnQnLCBhbW91bnQ6IGFtb3VudH1cbiAgfSBlbHNlIHtcbiAgICBvYmplY3Rba2V5XS5hbW91bnQgKz0gYW1vdW50O1xuICB9XG4gIHJldHVybiBvYmplY3Rba2V5XTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZsYXR0ZW4oYXJyYXkpIHtcbiAgdmFyIGZsYXR0ZW5lZCA9IFtdO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICBpZihBcnJheS5pc0FycmF5KGFycmF5W2ldKSkge1xuICAgICAgZmxhdHRlbmVkID0gZmxhdHRlbmVkLmNvbmNhdChmbGF0dGVuKGFycmF5W2ldKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZsYXR0ZW5lZC5wdXNoKGFycmF5W2ldKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZsYXR0ZW5lZDtcbn1cblxuZnVuY3Rpb24gc3RhdHVzSGFuZGxlcihjbGFzc05hbWUsIGRhdGFiYXNlKSB7XG4gIGxldCBsYXN0UHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSgpO1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZShvYmplY3QpIHtcbiAgICBsYXN0UHJvbWlzZSA9IGxhc3RQcm9taXNlLnRoZW4oKCkgPT4ge1xuICAgICAgcmV0dXJuIGRhdGFiYXNlLmNyZWF0ZShjbGFzc05hbWUsIG9iamVjdCkudGhlbigoKSA9PiB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUob2JqZWN0KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiBsYXN0UHJvbWlzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZSh3aGVyZSwgb2JqZWN0KSB7XG4gICAgbGFzdFByb21pc2UgPSBsYXN0UHJvbWlzZS50aGVuKCgpID0+IHtcbiAgICAgIHJldHVybiBkYXRhYmFzZS51cGRhdGUoY2xhc3NOYW1lLCB3aGVyZSwgb2JqZWN0KTtcbiAgICB9KTtcbiAgICByZXR1cm4gbGFzdFByb21pc2U7XG4gIH1cblxuICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7XG4gICAgY3JlYXRlLFxuICAgIHVwZGF0ZVxuICB9KVxufVxuXG5mdW5jdGlvbiByZXN0U3RhdHVzSGFuZGxlcihjbGFzc05hbWUsIGNvbmZpZykge1xuICBsZXQgbGFzdFByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoKTtcbiAgY29uc3QgYXV0aCA9IEF1dGgubWFzdGVyKGNvbmZpZyk7XG4gIGZ1bmN0aW9uIGNyZWF0ZShvYmplY3QpIHtcbiAgICBsYXN0UHJvbWlzZSA9IGxhc3RQcm9taXNlLnRoZW4oKCkgPT4ge1xuICAgICAgcmV0dXJuIHJlc3QuY3JlYXRlKGNvbmZpZywgYXV0aCwgY2xhc3NOYW1lLCBvYmplY3QpXG4gICAgICAgIC50aGVuKCh7IHJlc3BvbnNlIH0pID0+IHtcbiAgICAgICAgICAvLyBtZXJnZSB0aGUgb2JqZWN0c1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoT2JqZWN0LmFzc2lnbih7fSwgb2JqZWN0LCByZXNwb25zZSkpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gbGFzdFByb21pc2U7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGUod2hlcmUsIG9iamVjdCkge1xuICAgIC8vIFRPRE86IHdoZW4gd2UgaGF2ZSB1cGRhdGVXaGVyZSwgdXNlIHRoYXQgZm9yIHByb3BlciBpbnRlcmZhY2luZ1xuICAgIGxhc3RQcm9taXNlID0gbGFzdFByb21pc2UudGhlbigoKSA9PiB7XG4gICAgICByZXR1cm4gcmVzdC51cGRhdGUoY29uZmlnLCBhdXRoLCBjbGFzc05hbWUsIHsgb2JqZWN0SWQ6IHdoZXJlLm9iamVjdElkIH0sIG9iamVjdClcbiAgICAgICAgLnRoZW4oKHsgcmVzcG9uc2UgfSkgPT4ge1xuICAgICAgICAgIC8vIG1lcmdlIHRoZSBvYmplY3RzXG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShPYmplY3QuYXNzaWduKHt9LCBvYmplY3QsIHJlc3BvbnNlKSk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiBsYXN0UHJvbWlzZTtcbiAgfVxuXG4gIHJldHVybiBPYmplY3QuZnJlZXplKHtcbiAgICBjcmVhdGUsXG4gICAgdXBkYXRlXG4gIH0pXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBqb2JTdGF0dXNIYW5kbGVyKGNvbmZpZykge1xuICBsZXQgam9iU3RhdHVzO1xuICBjb25zdCBvYmplY3RJZCA9IG5ld09iamVjdElkKGNvbmZpZy5vYmplY3RJZFNpemUpO1xuICBjb25zdCBkYXRhYmFzZSA9IGNvbmZpZy5kYXRhYmFzZTtcbiAgY29uc3QgaGFuZGxlciA9IHN0YXR1c0hhbmRsZXIoSk9CX1NUQVRVU19DT0xMRUNUSU9OLCBkYXRhYmFzZSk7XG4gIGNvbnN0IHNldFJ1bm5pbmcgPSBmdW5jdGlvbihqb2JOYW1lLCBwYXJhbXMpIHtcbiAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpO1xuICAgIGpvYlN0YXR1cyA9IHtcbiAgICAgIG9iamVjdElkLFxuICAgICAgam9iTmFtZSxcbiAgICAgIHBhcmFtcyxcbiAgICAgIHN0YXR1czogJ3J1bm5pbmcnLFxuICAgICAgc291cmNlOiAnYXBpJyxcbiAgICAgIGNyZWF0ZWRBdDogbm93LFxuICAgICAgLy8gbG9ja2Rvd24hXG4gICAgICBBQ0w6IHt9XG4gICAgfVxuXG4gICAgcmV0dXJuIGhhbmRsZXIuY3JlYXRlKGpvYlN0YXR1cyk7XG4gIH1cblxuICBjb25zdCBzZXRNZXNzYWdlID0gZnVuY3Rpb24obWVzc2FnZSkge1xuICAgIGlmICghbWVzc2FnZSB8fCB0eXBlb2YgbWVzc2FnZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgcmV0dXJuIGhhbmRsZXIudXBkYXRlKHsgb2JqZWN0SWQgfSwgeyBtZXNzYWdlIH0pO1xuICB9XG5cbiAgY29uc3Qgc2V0U3VjY2VlZGVkID0gZnVuY3Rpb24obWVzc2FnZSkge1xuICAgIHJldHVybiBzZXRGaW5hbFN0YXR1cygnc3VjY2VlZGVkJywgbWVzc2FnZSk7XG4gIH1cblxuICBjb25zdCBzZXRGYWlsZWQgPSBmdW5jdGlvbihtZXNzYWdlKSB7XG4gICAgcmV0dXJuIHNldEZpbmFsU3RhdHVzKCdmYWlsZWQnLCBtZXNzYWdlKTtcbiAgfVxuXG4gIGNvbnN0IHNldEZpbmFsU3RhdHVzID0gZnVuY3Rpb24oc3RhdHVzLCBtZXNzYWdlID0gdW5kZWZpbmVkKSB7XG4gICAgY29uc3QgZmluaXNoZWRBdCA9IG5ldyBEYXRlKCk7XG4gICAgY29uc3QgdXBkYXRlID0geyBzdGF0dXMsIGZpbmlzaGVkQXQgfTtcbiAgICBpZiAobWVzc2FnZSAmJiB0eXBlb2YgbWVzc2FnZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHVwZGF0ZS5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICB9XG4gICAgcmV0dXJuIGhhbmRsZXIudXBkYXRlKHsgb2JqZWN0SWQgfSwgdXBkYXRlKTtcbiAgfVxuXG4gIHJldHVybiBPYmplY3QuZnJlZXplKHtcbiAgICBzZXRSdW5uaW5nLFxuICAgIHNldFN1Y2NlZWRlZCxcbiAgICBzZXRNZXNzYWdlLFxuICAgIHNldEZhaWxlZFxuICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHB1c2hTdGF0dXNIYW5kbGVyKGNvbmZpZywgZXhpc3RpbmdPYmplY3RJZCkge1xuXG4gIGxldCBwdXNoU3RhdHVzO1xuICBjb25zdCBkYXRhYmFzZSA9IGNvbmZpZy5kYXRhYmFzZTtcbiAgY29uc3QgaGFuZGxlciA9IHJlc3RTdGF0dXNIYW5kbGVyKFBVU0hfU1RBVFVTX0NPTExFQ1RJT04sIGNvbmZpZyk7XG4gIGxldCBvYmplY3RJZCA9IGV4aXN0aW5nT2JqZWN0SWQ7XG4gIGNvbnN0IHNldEluaXRpYWwgPSBmdW5jdGlvbihib2R5ID0ge30sIHdoZXJlLCBvcHRpb25zID0ge3NvdXJjZTogJ3Jlc3QnfSkge1xuICAgIGNvbnN0IG5vdyA9IG5ldyBEYXRlKCk7XG4gICAgbGV0IHB1c2hUaW1lID0gbm93LnRvSVNPU3RyaW5nKCk7XG4gICAgbGV0IHN0YXR1cyA9ICdwZW5kaW5nJztcbiAgICBpZiAoYm9keS5oYXNPd25Qcm9wZXJ0eSgncHVzaF90aW1lJykpIHtcbiAgICAgIGlmIChjb25maWcuaGFzUHVzaFNjaGVkdWxlZFN1cHBvcnQpIHtcbiAgICAgICAgcHVzaFRpbWUgPSBib2R5LnB1c2hfdGltZTtcbiAgICAgICAgc3RhdHVzID0gJ3NjaGVkdWxlZCc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsb2dnZXIud2FybignVHJ5aW5nIHRvIHNjaGVkdWxlIGEgcHVzaCB3aGlsZSBzZXJ2ZXIgaXMgbm90IGNvbmZpZ3VyZWQuJyk7XG4gICAgICAgIGxvZ2dlci53YXJuKCdQdXNoIHdpbGwgYmUgc2VudCBpbW1lZGlhdGVseScpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGRhdGEgPSAgYm9keS5kYXRhIHx8IHt9O1xuICAgIGNvbnN0IHBheWxvYWRTdHJpbmcgPSBKU09OLnN0cmluZ2lmeShkYXRhKTtcbiAgICBsZXQgcHVzaEhhc2g7XG4gICAgaWYgKHR5cGVvZiBkYXRhLmFsZXJ0ID09PSAnc3RyaW5nJykge1xuICAgICAgcHVzaEhhc2ggPSBtZDVIYXNoKGRhdGEuYWxlcnQpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGRhdGEuYWxlcnQgPT09ICdvYmplY3QnKSB7XG4gICAgICBwdXNoSGFzaCA9IG1kNUhhc2goSlNPTi5zdHJpbmdpZnkoZGF0YS5hbGVydCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwdXNoSGFzaCA9ICdkNDFkOGNkOThmMDBiMjA0ZTk4MDA5OThlY2Y4NDI3ZSc7XG4gICAgfVxuICAgIGNvbnN0IG9iamVjdCA9IHtcbiAgICAgIHB1c2hUaW1lLFxuICAgICAgcXVlcnk6IEpTT04uc3RyaW5naWZ5KHdoZXJlKSxcbiAgICAgIHBheWxvYWQ6IHBheWxvYWRTdHJpbmcsXG4gICAgICBzb3VyY2U6IG9wdGlvbnMuc291cmNlLFxuICAgICAgdGl0bGU6IG9wdGlvbnMudGl0bGUsXG4gICAgICBleHBpcnk6IGJvZHkuZXhwaXJhdGlvbl90aW1lLFxuICAgICAgZXhwaXJhdGlvbl9pbnRlcnZhbDogYm9keS5leHBpcmF0aW9uX2ludGVydmFsLFxuICAgICAgc3RhdHVzOiBzdGF0dXMsXG4gICAgICBudW1TZW50OiAwLFxuICAgICAgcHVzaEhhc2gsXG4gICAgICAvLyBsb2NrZG93biFcbiAgICAgIEFDTDoge31cbiAgICB9XG4gICAgcmV0dXJuIGhhbmRsZXIuY3JlYXRlKG9iamVjdCkudGhlbigocmVzdWx0KSA9PiB7XG4gICAgICBvYmplY3RJZCA9IHJlc3VsdC5vYmplY3RJZDtcbiAgICAgIHB1c2hTdGF0dXMgPSB7XG4gICAgICAgIG9iamVjdElkXG4gICAgICB9O1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShwdXNoU3RhdHVzKTtcbiAgICB9KTtcbiAgfVxuXG4gIGNvbnN0IHNldFJ1bm5pbmcgPSBmdW5jdGlvbihiYXRjaGVzKSB7XG4gICAgbG9nZ2VyLnZlcmJvc2UoYF9QdXNoU3RhdHVzICR7b2JqZWN0SWR9OiBzZW5kaW5nIHB1c2ggdG8gaW5zdGFsbGF0aW9ucyB3aXRoICVkIGJhdGNoZXNgLCBiYXRjaGVzKTtcbiAgICByZXR1cm4gaGFuZGxlci51cGRhdGUoXG4gICAgICB7XG4gICAgICAgIHN0YXR1czpcInBlbmRpbmdcIixcbiAgICAgICAgb2JqZWN0SWQ6IG9iamVjdElkXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBzdGF0dXM6IFwicnVubmluZ1wiLFxuICAgICAgICBjb3VudDogYmF0Y2hlc1xuICAgICAgfVxuICAgICk7XG4gIH1cblxuICBjb25zdCB1cGRhdGUgPSBmdW5jdGlvbih1cGRhdGUpIHtcbiAgICBsb2dnZXIudmVyYm9zZShgX1B1c2hTdGF0dXMgJHtvYmplY3RJZH06IHVwZGF0aW5nIHZhbHVlcyAlamAsIHVwZGF0ZSk7XG4gICAgcmV0dXJuIGhhbmRsZXIudXBkYXRlKHsgb2JqZWN0SWQgfSwgdXBkYXRlKTtcbiAgfVxuXG4gIGNvbnN0IHRyYWNrU2VudCA9IGZ1bmN0aW9uKHJlc3VsdHMsIFVUQ09mZnNldCwgY2xlYW51cEluc3RhbGxhdGlvbnMgPSBwcm9jZXNzLmVudi5QQVJTRV9TRVJWRVJfQ0xFQU5VUF9JTlZBTElEX0lOU1RBTExBVElPTlMpIHtcbiAgICBjb25zdCB1cGRhdGUgPSB7XG4gICAgICBudW1TZW50OiAwLFxuICAgICAgbnVtRmFpbGVkOiAwXG4gICAgfTtcbiAgICBjb25zdCBkZXZpY2VzVG9SZW1vdmUgPSBbXTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShyZXN1bHRzKSkge1xuICAgICAgcmVzdWx0cyA9IGZsYXR0ZW4ocmVzdWx0cyk7XG4gICAgICByZXN1bHRzLnJlZHVjZSgobWVtbywgcmVzdWx0KSA9PiB7XG4gICAgICAgIC8vIENhbm5vdCBoYW5kbGUgdGhhdFxuICAgICAgICBpZiAoIXJlc3VsdCB8fCAhcmVzdWx0LmRldmljZSB8fCAhcmVzdWx0LmRldmljZS5kZXZpY2VUeXBlKSB7XG4gICAgICAgICAgcmV0dXJuIG1lbW87XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGV2aWNlVHlwZSA9IHJlc3VsdC5kZXZpY2UuZGV2aWNlVHlwZTtcbiAgICAgICAgY29uc3Qga2V5ID0gcmVzdWx0LnRyYW5zbWl0dGVkID8gYHNlbnRQZXJUeXBlLiR7ZGV2aWNlVHlwZX1gIDogYGZhaWxlZFBlclR5cGUuJHtkZXZpY2VUeXBlfWA7XG4gICAgICAgIG1lbW9ba2V5XSA9IGluY3JlbWVudE9wKG1lbW8sIGtleSk7XG4gICAgICAgIGlmICh0eXBlb2YgVVRDT2Zmc2V0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIGNvbnN0IG9mZnNldEtleSA9IHJlc3VsdC50cmFuc21pdHRlZCA/IGBzZW50UGVyVVRDT2Zmc2V0LiR7VVRDT2Zmc2V0fWAgOiBgZmFpbGVkUGVyVVRDT2Zmc2V0LiR7VVRDT2Zmc2V0fWA7XG4gICAgICAgICAgbWVtb1tvZmZzZXRLZXldID0gaW5jcmVtZW50T3AobWVtbywgb2Zmc2V0S2V5KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0LnRyYW5zbWl0dGVkKSB7XG4gICAgICAgICAgbWVtby5udW1TZW50Kys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHJlc3VsdCAmJiByZXN1bHQucmVzcG9uc2UgJiYgcmVzdWx0LnJlc3BvbnNlLmVycm9yICYmIHJlc3VsdC5kZXZpY2UgJiYgcmVzdWx0LmRldmljZS5kZXZpY2VUb2tlbikge1xuICAgICAgICAgICAgY29uc3QgdG9rZW4gPSByZXN1bHQuZGV2aWNlLmRldmljZVRva2VuO1xuICAgICAgICAgICAgY29uc3QgZXJyb3IgPSByZXN1bHQucmVzcG9uc2UuZXJyb3I7XG4gICAgICAgICAgICAvLyBHQ00gZXJyb3JzXG4gICAgICAgICAgICBpZiAoZXJyb3IgPT09ICdOb3RSZWdpc3RlcmVkJyB8fCBlcnJvciA9PT0gJ0ludmFsaWRSZWdpc3RyYXRpb24nKSB7XG4gICAgICAgICAgICAgIGRldmljZXNUb1JlbW92ZS5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEFQTlMgZXJyb3JzXG4gICAgICAgICAgICBpZiAoZXJyb3IgPT09ICdVbnJlZ2lzdGVyZWQnIHx8IGVycm9yID09PSAnQmFkRGV2aWNlVG9rZW4nKSB7XG4gICAgICAgICAgICAgIGRldmljZXNUb1JlbW92ZS5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgbWVtby5udW1GYWlsZWQrKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVtbztcbiAgICAgIH0sIHVwZGF0ZSk7XG4gICAgfVxuXG4gICAgbG9nZ2VyLnZlcmJvc2UoYF9QdXNoU3RhdHVzICR7b2JqZWN0SWR9OiBzZW50IHB1c2ghICVkIHN1Y2Nlc3MsICVkIGZhaWx1cmVzYCwgdXBkYXRlLm51bVNlbnQsIHVwZGF0ZS5udW1GYWlsZWQpO1xuICAgIGxvZ2dlci52ZXJib3NlKGBfUHVzaFN0YXR1cyAke29iamVjdElkfTogbmVlZHMgY2xlYW51cGAsIHsgZGV2aWNlc1RvUmVtb3ZlIH0pO1xuICAgIFsnbnVtU2VudCcsICdudW1GYWlsZWQnXS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgIGlmICh1cGRhdGVba2V5XSA+IDApIHtcbiAgICAgICAgdXBkYXRlW2tleV0gPSB7XG4gICAgICAgICAgX19vcDogJ0luY3JlbWVudCcsXG4gICAgICAgICAgYW1vdW50OiB1cGRhdGVba2V5XVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVsZXRlIHVwZGF0ZVtrZXldO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKGRldmljZXNUb1JlbW92ZS5sZW5ndGggPiAwICYmIGNsZWFudXBJbnN0YWxsYXRpb25zKSB7XG4gICAgICBsb2dnZXIuaW5mbyhgUmVtb3ZpbmcgZGV2aWNlIHRva2VucyBvbiAke2RldmljZXNUb1JlbW92ZS5sZW5ndGh9IF9JbnN0YWxsYXRpb25zYCk7XG4gICAgICBkYXRhYmFzZS51cGRhdGUoJ19JbnN0YWxsYXRpb24nLCB7IGRldmljZVRva2VuOiB7ICckaW4nOiBkZXZpY2VzVG9SZW1vdmUgfX0sIHsgZGV2aWNlVG9rZW46IHtcIl9fb3BcIjogXCJEZWxldGVcIn0gfSwge1xuICAgICAgICBhY2w6IHVuZGVmaW5lZCxcbiAgICAgICAgbWFueTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gaW5kaWNhdGUgdGhpcyBiYXRjaCBpcyBjb21wbGV0ZVxuICAgIGluY3JlbWVudE9wKHVwZGF0ZSwgJ2NvdW50JywgLTEpO1xuXG4gICAgcmV0dXJuIGhhbmRsZXIudXBkYXRlKHsgb2JqZWN0SWQgfSwgdXBkYXRlKS50aGVuKChyZXMpID0+IHtcbiAgICAgIGlmIChyZXMgJiYgcmVzLmNvdW50ID09PSAwKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBsZXRlKCk7XG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIGNvbnN0IGNvbXBsZXRlID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGhhbmRsZXIudXBkYXRlKHsgb2JqZWN0SWQgfSwge1xuICAgICAgc3RhdHVzOiAnc3VjY2VlZGVkJyxcbiAgICAgIGNvdW50OiB7X19vcDogJ0RlbGV0ZSd9XG4gICAgfSk7XG4gIH1cblxuICBjb25zdCBmYWlsID0gZnVuY3Rpb24oZXJyKSB7XG4gICAgaWYgKHR5cGVvZiBlcnIgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlcnIgPSB7IG1lc3NhZ2U6IGVyciB9O1xuICAgIH1cbiAgICBjb25zdCB1cGRhdGUgPSB7XG4gICAgICBlcnJvck1lc3NhZ2U6IGVycixcbiAgICAgIHN0YXR1czogJ2ZhaWxlZCdcbiAgICB9XG4gICAgcmV0dXJuIGhhbmRsZXIudXBkYXRlKHsgb2JqZWN0SWQgfSwgdXBkYXRlKTtcbiAgfVxuXG4gIGNvbnN0IHJ2YWwgPSB7XG4gICAgc2V0SW5pdGlhbCxcbiAgICBzZXRSdW5uaW5nLFxuICAgIHRyYWNrU2VudCxcbiAgICBjb21wbGV0ZSxcbiAgICB1cGRhdGUsXG4gICAgZmFpbFxuICB9O1xuXG4gIC8vIGRlZmluZSBvYmplY3RJZCB0byBiZSBkeW5hbWljXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShydmFsLCBcIm9iamVjdElkXCIsIHtcbiAgICBnZXQ6ICgpID0+IG9iamVjdElkXG4gIH0pO1xuXG4gIHJldHVybiBPYmplY3QuZnJlZXplKHJ2YWwpO1xufVxuIl19